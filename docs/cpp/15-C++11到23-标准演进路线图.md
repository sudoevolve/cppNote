# 15-C++11 到 C++23：标准演进路线图（你该学什么）

目录页：见 [C++ 小白教程目录](00-目录.md)

## 目标

- 一次看清 C++11/14/17/20/23 各自“最值得掌握”的变化
- 能根据你的场景选择合适的标准版本与编译选项
- 建立一个学习顺序：先学哪些能立刻提升写代码体验

## 先决知识（建议）

- 你已经写过函数/类/容器与算法（见 02、05、07、08 章）

---

## 1. 一张总览表：每个版本最核心的东西

| 标准 | 你会明显感觉到的变化（语言） | 你会马上用到的变化（标准库） |
| --- | --- | --- |
| C++11 | auto、range-for、lambda、移动语义、nullptr | 智能指针、thread/chrono、unordered_map |
| C++14 | 泛型 lambda、返回类型推导（更顺手） | `std::make_unique` |
| C++17 | 结构化绑定、`if constexpr` | `optional/variant/any`、filesystem、string_view |
| C++20 | Concepts、Ranges、`<=>`、constexpr 大增强 | `std::span`、`std::format`、更多并发工具 |
| C++23 | 语法补强（更细碎但更顺手） | `expected`、`print`、`ranges::to`、string contains |

你可以把它理解成：

- C++11/14/17：把 C++ 从“危险但强”变成“可写可维护”
- C++20：把“泛型编程与组合式写法”推到新一层
- C++23：在 C++20 的基础上把标准库补齐，让很多事情更顺手

---

## 1.1 快速必学清单（按“收益/常用度”排序）

如果你不想按年份学，可以按“最值钱的能力”来学：

- 第一梯队（必须会）：C++11 的 auto/range-for/lambda/移动语义/智能指针
- 第二梯队（强烈建议）：C++17 的结构化绑定、`if constexpr`、`optional/variant`、filesystem（做项目很常见）
- 第三梯队（很值得）：C++20 的 Concepts、Ranges、`std::span`、`std::format`、`std::jthread`
- 第四梯队（看环境）：C++23 的 `expected`、`ranges::to`、新的 views（zip/enumerate）、`std::print`

你可以把它当作“学习顺序”，而不是“标准发布时间表”。

---

## 2. C++11：现代 C++ 的地基（必须会）

### 2.1 auto / range-for：少写重复类型与迭代器样板

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> v{1, 2, 3};
    for (int x : v) {
        std::cout << "x=" << x << '\n';
    }
    return 0;
}
```

### 2.2 lambda：把“小函数”写在使用现场

```cpp
#include <algorithm>
#include <iostream>
#include <vector>

int main() {
    std::vector<int> v{3, 1, 2};
    std::sort(v.begin(), v.end(), [](int a, int b) { return a < b; });
    for (int x : v) std::cout << "x=" << x << '\n';
    return 0;
}
```

### 2.3 移动语义 + 智能指针：更安全的资源管理

如果你只记一句话：

- 新代码优先用 `std::unique_ptr` / `std::shared_ptr`，尽量别手写 `new/delete`（见 06 章）

### 2.4 nullptr 与 enum class：更少歧义

高频结论：

- 指针用 `nullptr`，不要用 `0` 或 `NULL`
- 需要“强类型枚举”时用 `enum class`

---

## 3. C++14：把 C++11 的“别扭处”打磨顺滑

高频点：

- 泛型 lambda：`[](auto x) { ... }`
- `std::make_unique`：统一用工厂创建 `unique_ptr`

---

## 4. C++17：让模板与日常代码都更好写

### 4.1 结构化绑定：拆 pair/tuple 更直观

```cpp
#include <iostream>
#include <map>
#include <string>

int main() {
    std::map<std::string, int> m{{"a", 1}, {"b", 2}};
    for (const auto& [key, value] : m) {
        std::cout << "key=" << key << " value=" << value << '\n';
    }
    return 0;
}
```

### 4.2 `if constexpr`：模板分支真正“按类型剪枝”

直觉：如果你写泛型代码，总会遇到“某些类型走分支 A，某些类型走分支 B”。C++17 让这件事更自然（并且能编译期消除无关分支）。

### 4.3 标准库三件套：optional / variant / any

你可以先用一句话记住它们的定位：

- `optional<T>`：可能有值也可能没值
- `variant<A, B, ...>`：多选一（但一定有一个）
- `any`：什么都能装（但类型信息在运行期，代价更大）

### 4.4 filesystem：做项目经常要用到

如果你写过“读文件/列目录/拼路径”，你会发现 C++17 的 filesystem 让这件事更统一。

---

## 5. C++20：从“能写”到“写得更像表达式”

这一版是“现代 C++ 2.0”的分水岭：

- Concepts：模板约束更可读，报错更友好
- Ranges：把过滤/变换组合成流水线
- Coroutines：语言级“暂停/继续”
- Modules：替代头文件的长期方向

对应入门：见 [13-C++20 新特性：Concepts、Ranges、Coroutines、Modules（入门）](13-C++20新特性-ConceptsRangesCoroutinesModules.md)

---

## 6. C++23：把常用工具补齐（标准库更“趁手”）

高频且值得学的点：

- `std::expected`：表达“可能失败”
- `std::ranges::to`：让 Ranges 结果更容易落地成容器
- `std::print/std::println`：输出更直观
- `string::contains`：子串判断更自然

对应入门：见 [14-C++23 新特性：标准库更好用与语法补强（入门）](14-C++23新特性-标准库更好用与语法补强.md)

---

## 7. 我该选哪个标准？（按场景给建议）

- 你在学 C++ / 写普通项目：优先 C++20；如果环境不支持，就用 C++17
- 你在刷题/比赛：C++17 往往兼容最好；环境允许的话 C++20 也很舒服（ranges 不一定开放）
- 你在做大型工程：看工具链与第三方库支持程度，再决定 C++20/23 的落地范围（尤其是 modules）

### 7.1 一个更具体的选型方法（不纠结）

- 你能统一到“新编译器 + 新标准库”：直接选 C++20，按需打开 C++23
- 你要兼容老环境（比如学校机房/老服务器/比赛评测）：选 C++17，保证能编译
- 你在团队里推进升级：先把代码风格现代化（智能指针、range-for、RAII），再谈更高标准

---

## 8. 编译选项怎么写（常见编译器）

下面是“概念上”的写法，你的 IDE/构建系统可能会把它藏在设置里：

- GCC/Clang：`-std=c++17` / `-std=c++20` / `-std=c++23`
- MSVC：`/std:c++17` / `/std:c++20` / `/std:c++latest`（C++23 支持随版本变化）

---

## 小结

- 先把 C++11/14/17 的日常写法吃透，这是现代 C++ 的基础
- C++20 把泛型与组合式写法推到一个新层级，值得系统学
- C++23 是“补齐工具箱”，用得上就很爽，但要看环境支持

上一篇：见 [14-C++23 新特性：标准库更好用与语法补强（入门）](14-C++23新特性-标准库更好用与语法补强.md)
下一篇：见 [16-CMake 入门：从单文件到多目标工程](16-CMake入门-从单文件到多目标工程.md)
